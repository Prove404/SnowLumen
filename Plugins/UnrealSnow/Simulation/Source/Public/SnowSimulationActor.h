// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "Landscape.h"
#include "GameFramework/Actor.h"
#include "GenericPlatform/GenericPlatformFile.h"
#include "SimulationWeatherDataProviderBase.h"
#include "SimulationBase.h"
#include "Cells/LandscapeCell.h"
#include "Cells/DebugCell.h"
// #include "VirtualHeightfieldMesh/VirtualHeightfieldMesh.h" // VirtualHeightfieldMesh not available in UE5.6
#include "Materials/MaterialInterface.h"
#include "SnowSimulationActor.generated.h"

// Forward declarations
class UTexture2D;
class UMaterialInstanceDynamic;

DECLARE_LOG_CATEGORY_EXTERN(SimulationLog, Log, All);

UENUM(BlueprintType)
enum class EDebugVisualizationType : uint8
{
	Nothing 		UMETA(DisplayName = "Nothing"),
	SnowHeight		UMETA(DisplayName = "Snow Height (mm)"),
	SWE 			UMETA(DisplayName = "Snow Water Equivalent (l)"),
	Position 		UMETA(DisplayName = "Position"),
	Altitude 		UMETA(DisplayName = "Altitude (cm)"),
	Index 			UMETA(DisplayName = "Cell Index"),
	Area 			UMETA(DisplayName = "Area (m^2)"),
	Curvature		UMETA(DisplayName = "Curvature"),
	Aspect			UMETA(DisplayName = "Aspect (degrees)"),
};


UCLASS()
class SIMULATION_API ASnowSimulationActor : public AActor
{
	GENERATED_BODY()
	
public:	
	//@TODO make cell creation algorithm independent of section size
	/** Size of one cell (in vertices) of the simulation, should be divisible by the quad section size. */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	int CellSize = 9;
	
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Simulation")
	/** The current date of the simulation. */
	FDateTime CurrentSimulationTime;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** Simulation start time. */
	FDateTime StartTime = FDateTime(2015, 10, 1);

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** Simulation end time. */
	FDateTime EndTime = FDateTime(2016, 9, 1);

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** Unit vector which points north. */
	FVector North = { 1,0,0 };

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** The Longitude in degrees of the top left vertex of the top left cell (Northwest). */
	float Longitude;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** The Longitude in degrees of the top left vertex of the top left cell (Northwest). */
	float Latitude;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** Number of timesteps to be executed for each iteration. */
	int32 Timesteps = 1;

	// Base simulation selection (inline or class)
	UPROPERTY(EditAnywhere, Category = "Simulation|Select", meta=(Tooltip="If true, InlineSimulationClass is used; otherwise the project default is used."))
	bool UseInlineSimulation = true;

	UPROPERTY(EditAnywhere, Category = "Simulation|Select", meta=(EditCondition="UseInlineSimulation", HideEditConditionToggle, Tooltip="If UseInlineSimulation=true, InlineSimulationClass is used; otherwise the project default is used."))
	TSubclassOf<USimulationBase> InlineSimulationClass;

	// Legacy simulation field - hidden from editor
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Simulation", meta=(AdvancedDisplay))
	/** @deprecated Use UseInlineSimulation and InlineSimulationClass instead */
	USimulationBase* Simulation;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** Time in seconds until the next step of the simulation is executed. */
	float SleepTime = 1.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation")
	/** Wheter to draw the date on the screen or not. */
	bool DrawDate = true;

	/** Validates that required material parameters are present */
	bool ValidateMaterialParameters(UMaterialInterface* BaseMat);

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	/** What should be visualized.  */
	EDebugVisualizationType DebugVisualizationType = EDebugVisualizationType::Nothing;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	/** Render the simulation grid over the landscape. */
	bool RenderGrid = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	/** Offset of the grids z position. */
	float DebugGridZOffset = 50.0f;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	/** If true, writes the textures generated by the simulation for the material to the screenshot folder. */
	bool SaveMaterialTextures = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	/** If true takes a screenshot each time an iteration of the simulation is executed. */
	bool SaveSimulationFrames = false;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Debug")
	int CellDebugInfoDisplayDistance = 15000;

	// PIE auto-run controls
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation|Run")
	bool bAutoRun = true;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation|Run", meta=(ClampMin="1", ClampMax="120"))
	int32 SimRateHz = 4;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Simulation|Run", meta=(ClampMin="1"))
	float SimDtSeconds = 3600.0f; // 1 hour per step

	// Material selection & binding behavior
	UPROPERTY(EditAnywhere, Category = "Snow|Material")
	TSoftObjectPtr<UMaterialInterface> SnowSurfaceMaterial; // default to /Game/Materials/M_VHM_Snow

	UPROPERTY(EditAnywhere, Category = "Snow|Material", meta = (ClampMin = "0"))
	int32 TargetVHMSlotIndex = 0;

	UPROPERTY(EditAnywhere, Category = "Snow|Material")
	bool bOverrideExistingMaterial = true;

	// Parameter names (allow remap if user material differs)
	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SnowDepthTex = TEXT("SnowDepthTex");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SnowOriginMeters = TEXT("SnowOriginMeters");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SnowInvSizePerMeter = TEXT("SnowInvSizePerMeter");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SnowDisplacementScale = TEXT("SnowDisplacementScale");

	// Additional parameter names for landscape and other materials
	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SnowMap = TEXT("SnowMap");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_CellsDimensionX = TEXT("CellsDimensionX");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_CellsDimensionY = TEXT("CellsDimensionY");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_ResolutionX = TEXT("ResolutionX");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_ResolutionY = TEXT("ResolutionY");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_MaxSnow = TEXT("MaxSnow");

	// Optional: directly pick the target VHM component or actor
	// UPROPERTY(EditAnywhere, Category = "Snow|Binding")
	// TWeakObjectPtr<class AVirtualHeightfieldMesh> TargetVHMActor; // VirtualHeightfieldMesh not available in UE5.6

	// Visual/surface controls
	UPROPERTY(EditAnywhere, Category = "Snow|Visual")
	float SnowAlbedo_WSA = 0.95f;   // white-sky albedo  (diffuse env)

	UPROPERTY(EditAnywhere, Category = "Snow|Visual")
	float SnowAlbedo_BSA = 0.85f;   // black-sky albedo  (direct sun)

	UPROPERTY(EditAnywhere, Category = "Snow|Visual", meta = (ClampMin = "0.0"))
	float SnowRoughnessBase = 0.35f;

	UPROPERTY(EditAnywhere, Category = "Snow|Visual", meta = (ClampMin = "0.0"))
	float SparkleIntensity = 0.25f;   // small, additive spec lobe

	UPROPERTY(EditAnywhere, Category = "Snow|Visual", meta = (ClampMin = "0.001"))
	float SparkleScale = 0.5f;        // world-space frequency (m^-1)

	// Physically-inspired knobs (optional; can be ignored by the material)
	// Note: Age and impurity automatically adjust albedo/roughness via heuristics
	UPROPERTY(EditAnywhere, Category = "Snow|Physics")
	float SnowAgeDays = 0.0f;       // aging increases roughness, darkens albedo

	UPROPERTY(EditAnywhere, Category = "Snow|Physics")
	float GrainSize_um = 150.0f;    // affects albedo/roughness heuristics

	UPROPERTY(EditAnywhere, Category = "Snow|Physics")
	float Impurity_ppm = 0.0f;      // soot/dust â†’ albedo reduction

	// Parameter names (so your material can use any naming)
	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_AlbedoWSA = TEXT("Albedo_WSA");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_AlbedoBSA = TEXT("Albedo_BSA");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_RoughnessBase = TEXT("SnowRoughness");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SparkleIntensity = TEXT("SparkleIntensity");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SparkleScale = TEXT("SparkleScale");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_SnowAgeDays = TEXT("SnowAgeDays");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_Grain_um = TEXT("GrainSize_um");

	UPROPERTY(EditAnywhere, Category = "Snow|Material|Params")
	FName Param_Impurity_ppm = TEXT("Impurity_ppm");

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "VHM")
	float SnowDisplacementScale = 5.0f;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Debug")
	/** Number of simulation cells per dimension in x. */
	int32 CellsDimensionX;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Debug")
	/** Number of simulation cells per dimension in y. */
	int32 CellsDimensionY;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Debug")
	/** Landscape scale. */
	FVector LandscapeScale;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Debug")
	/** Overall landscape resolution in x dimension. */
	float OverallResolutionX;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Debug")
	/** Overall landscape resolution in y dimension. */
	float OverallResolutionY;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Debug")
	/** Total number of simulation cells. */
	int32 NumCells;

	/** Weather data provider for the simulation. */
	USimulationWeatherDataProviderBase* ClimateDataComponent;

	// Weather forcing system
	// Selection mode toggle: true = inline instance, false = class-based
	UPROPERTY(EditAnywhere, Category = "Weather|Provider", meta=(Tooltip="If true, InlineWeatherProvider is used; if false, WeatherProviderClass is used."))
	bool UseInlineWeatherProvider = true;

	// Inline instance edited in Details when inline mode is enabled
	UPROPERTY(EditAnywhere, Instanced, Category = "Weather|Provider", meta=(EditCondition="UseInlineWeatherProvider", EditConditionHides, ShowInnerProperties))
	USimulationWeatherDataProviderBase* InlineWeatherProvider = nullptr;

	// Class to instantiate at runtime when class mode is enabled
	UPROPERTY(EditAnywhere, Category = "Weather|Provider", meta=(EditCondition="!UseInlineWeatherProvider", HideEditConditionToggle, Tooltip="If UseInlineWeatherProvider=false, WeatherProviderClass is used."))
	TSubclassOf<USimulationWeatherDataProviderBase> WeatherProviderClass;

	// Runtime-resolved provider actually used (kept for backwards compatibility)
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Weather", meta=(AdvancedDisplay))
	/** @deprecated Use UseInlineWeatherProvider, InlineWeatherProvider, and WeatherProviderClass instead */
	USimulationWeatherDataProviderBase* WeatherProvider;

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weather")
	FDateTime SimulationStart = FDateTime(2025, 2, 14);

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weather")
	FDateTime SimulationEnd = FDateTime(2025, 2, 15);

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weather")
	float TimeStepSeconds = 3600.0f; // 1 hour default

	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Weather")
	bool bLoopTime = false;

	/** Default constructor. */
	ASnowSimulationActor();

	/** Called when the game starts or when spawned */
	virtual void BeginPlay() override;
	
	/** Called every frame */
	virtual void Tick( float DeltaSeconds ) override;

#if WITH_EDITOR
	// Called after a property has changed
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent) override;
#endif
	
	/** Initializes the simulation. */
	void Initialize();

	/** Resolves a concrete simulation instance, never returning the abstract base. */
	USimulationBase* ResolveSimulation();

	/** Fills the CPU depth buffer with a debug gradient and uploads it to the GPU. */
	UFUNCTION(CallInEditor, Category = "Debug")
	void DebugFillDepth(float MaxDepthMeters = 0.2f);

	/** Prints comprehensive status information for debugging. */
	UFUNCTION(CallInEditor, Category = "Debug")
	void PrintStatus();

	/** Called by simulations to update the CPU depth buffer (meters). */
	void UpdateCpuDepthMeters(const TArray<float>& InDepthMeters);

private:
	/** Current simulation time the simulation has slept. */
	float CurrentSleepTime;

	/** The current step of the simulation (in hours). */
	int32 CurrentSimulationStep = 0;

	/** Visual accumulator for PIE stepping (seconds). */
	float VisualAccumulator = 0.0f;

	/** Accumulates simulated seconds until a weather step (TimeStepSeconds) is executed. */
	float SimulatedSecondsAccumulator = 0.0f;

	/** Minimum and maximum snow water equivalent (SWE) of the landscape. */
	float MinSWE, MaxSWE;

	/** Max snow from the initial conditions. */
	float InitialMaxSnow;

	/** Landscape cells. */
	TArray<FLandscapeCell> LandscapeCells;

	/** Cells for debugging. */
	TArray<FDebugCell> DebugCells;

	/** Slope of the terrain. */
	UTexture2D* SlopeTexture;

	/** CPU-side snow depth buffer in meters (R16F layout). */
	TArray<FFloat16> CpuDepthMeters;

	/** GPU texture updated from CPU depth buffer (PF_R16F). */
	UTexture2D* SnowDepthTexture = nullptr;

	/** Cached dynamic material instance used to bind snow parameters. */
	UMaterialInstanceDynamic* SnowMID = nullptr;

	/** Cell size in meters (world). */
	float MetersPerCell = 0.0f;

	/** Flag to track if material validation passed - prevents tick if false. */
	bool bMaterialValidationPassed = false;

	/** The landscape of the world. */
	ALandscape* Landscape;

	/**
	* Updates the material with data from the simulation.
	*/
	void UpdateMaterialTexture();

	/** Performs a simulation substep; advances when accumulated seconds >= TimeStepSeconds. */
	void StepSimulation(float dtSeconds);

	/**
	* Sets up VHM integration if VHM actor is found.
	*/
	void SetupVHMIntegration();

	/**
	* Sets up VHM material parameters with given origin and size.
	*/
	void SetupVHMMaterialParameters(UPrimitiveComponent* PrimComponent, AActor* FoundActor, const FVector2D& OriginMeters, const FVector2D& SizeMeters);

	/**
	* Sets up landscape binding as fallback when VHM is not available.
	*/
	void SetupLandscapeBinding();

	/** Per-target parameter mapping to preserve VHM-specific vs Landscape-specific mappings */
	struct FRenderBinding
	{
		enum class ETarget { VHM, Landscape };
		ETarget Target;
		FVector2D OriginMeters;
		FVector2D SizeMeters;
		FVector2D InvSizePerMeter;
		bool bInitialized = false;
	};

	/**
	* Applies snow parameters using the stored render binding.
	*/
	void ApplySnowParams(const FRenderBinding& Binding, UTexture2D* SnowTex2D);

private:
	/** Material instance for VHM. */
	UMaterialInstanceDynamic* VHMMaterialInstance;

	/** Retry counter for VHM bounds not ready. */
	int32 VHMBoundsRetryCount = 0;

	FRenderBinding ActiveRenderBinding;

	/** 
	* Renders appropriate debug information.
	*/
	void DoRenderGrid();

	/** Renders the debug information from the simulation. */
	void DoRenderDebugInformation();

	/** Logs min/max/mean of CpuDepthMeters. */
	void LogDepthStats();

	/** Uploads CpuDepthMeters to SnowDepthTexture as PF_R16F via render thread. */
	void UploadDepthToTexture();

	/**
	* Returns the cell at the given x and y position or a nullptr if the indices are out of bounds.
	*
	* @param X
	* @param Y
	* @return the cell at the given x and y position or a nullptr if the indices are out of bounds.
	*/
	FLandscapeCell* GetCellChecked(int X, int Y)
	{
		return GetCellChecked(X + Y * CellsDimensionX);
	}

	/**
	* Returns the cell at the given index or nullptr if the index is out of bounds.
	*
	* @param Index the index of the cell
	* @return the cell at the given index or nullptr if the index is out of bounds
	*/
	FLandscapeCell* GetCellChecked(int Index)
	{
		return (Index >= 0 && Index < LandscapeCells.Num()) ? &LandscapeCells[Index] : nullptr;
	}

};
